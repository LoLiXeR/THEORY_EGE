# ВКЛЮЧЕНИЕ КОДА

NUM2 = False
NUM5 = False
NUM6 = False

NUM8_LETTER = False
NUM8_NUMBER = False

NUM12 = False
NUM13 = False

NUM14_1 = False
NUM14_2 = False
NUM14_3 = False

NUM15 = False
NUM16 = False
NUM17 = False
NUM23 = False

NUM24_1 = False
NUM24_2 = False
NUM24_3 = False
NUM24_4 = False

NUM25_1 = False
NUM25_2 = False

NUM26_1 = False
NUM26_2 = False
NUM26_3 = False

NUM27_1 = False
NUM27_2 = False

THEORY_PEREVOD = False
THEORY = False
SYSTEM_TABL = False


# Формулы для задач

# 1 Задание

# 1. Расставляем цифры с колличеством путей на каждый пункт на графе
# 2. Расставляем цифры с колличеством соединений возле каждого пункта на таблице
# 3. Ищем на графе по цифрам которые мы расставили пункты которые отличаются от других
# 4. Ищем похожие соединения путей графа в таблице по расставленым цифрам
# 5. От известных путей расставляем остальные
# 6. Перепроверяем все расставленые цифры (или буквы) названия путей (или городов) по таблице
# 7. Выполняем поставленую заданием цель

# Если отличающихся путей нет, действуем по такому же алгоритму, только ищем пути с наименьшим кол-вом повтроряющихся дорог 


# 3 Задание

# Нужные формулы:
# =ВПР(искомое_значение;таблица;номер_столбца;[интервальный_просмотр])
# В искомом значении выбираем ячейку с ID магазина/Артикулом
# В таблице выделяем полностью таблицу Товар/Магазин
# В номере столбца вписываем номер столбца который нас интересует (В таблице товар например могут потребовать Отдел (обычно столбец 2) или Цена за упаковку (обычно столбец 6))
# В интервальном просмотре всегда вписываем 0

# После завершения всех работ с =ВПР() просто включаем фильтры и идём добивать задание


# 4 Задание

# Чертим граф и расставляем известные нам буквы
#       /    \
#      0     1
#     / \   / \
#    0  1  0   1

# Если просят найти кол-во знаков закодированого слова, то есть 2 варианта продолжения графа:
# 1. Просто продолжаем наш граф как пойдёт
# 2. Чертим ответвление от самой короткой ветки

# 3. Строим таблицу
# Буква | кол-во повторений в слове | кол-во символов для кодирования

# Пример:

# По каналу связи передаются сообщения, содержащие только буквы: Б, К, Л, О, Н. Для передачи используется двоичный код, удовлетворяющий условию Фано. Кодовые слова для некоторых букв известны: Б - 1001, К - 11. Для трёх оставшихся букв Л, Н и О кодовые слова неизвестны. Какое наименьшее количество двоичных знаков требуется для кодирования слова КОЛОКОЛ?
# Условие Фано означает, что ни одно кодовое слово не является началом другого кодового слова, т.е. в нашем графе после буквы мы не можем продлевать этот отрезок дальше

# КОЛОКОЛ
# К | 2 | 2
# О | 3 | 1
# Л | 2 | 3

# 2*2+3*1+2*3=13
# Ответ: 13


# 7 Задание

# Аудио 
# I=K*m*i*t
# I - Размер в битах
# K - Кол-во каналов (моно - 1, стерео - 2, квадро - 4)
# m - Частота дискретизации (1 кГц = 1000 Гц)
# i - разрешение в битах
# t - Время в секундах

# Фото 
# N=2**i
# I=x*y*i
# I - Размер в битах
# x - Длина
# y - Высота
# i - вес 1 цвета в битах
# N - Кол-во цветов (палитра)

# Видео
# По факту то же самое что фото, только появляются FPS (кадры в секунду)
# I = x*y*i*FPS*t


# 9 Задание

# Нужные формулы:
# =НАИБОЛЬШИЙ(массив;k)
# =НАИМЕНЬШИЙ(массив;k)
# =СЧЁТЕСЛИ(диапазон;критерий)
# =ОСТАТ(число;делитель)
# =СТЕПЕНЬ(число;степень)
# =ЕСЛИ(лог_выражение;[значение_если_истина];[значение_если_ложь])
# =И(логическое_значение1;[логическое_значение2];...)
# =ИЛИ(логическое_значение1;[логическое_значение2];...)


# 10 Задание

# Скачиваем файл, нажимаем ctrl+F, расширеный поиск


# 11 Задание
# I=K*i
# N=2**i
# I - Бит на 1 пароль
# K - Длина пароля
# N - Мощность алфавита
# i - Вес 1 символа

#    /8    /1024      /1024      /1024
# Бит → Байт → Килобайт → Мегабайт → Гигабайт


# ТАБЛИЦА СИСТЕМ

if SYSTEM_TABL == True:
    SYST = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ*"
    X=int(input("Система счисления >>> "))
    z=""
    for i in SYST:
        if str(i)!=str(SYST[X]):
            z+=i
        else:
            break
    print(z)


# ПЕРЕВОД СИСТЕМ СЧИСЛЕНИЯ

if THEORY_PEREVOD == True:
    def PEREVOD(Z,SYS):
        AFT=""
        ALF="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        while Z!=0:
            if Z%SYS<=9:
                AFT+=str(Z%SYS)
            else:
                AFT+=ALF[(Z%SYS)-10]
            Z=Z//SYS
        AFT=AFT[::-1]
        return(AFT)

    def OBR(A,SYSTEM):
        return int(str(A),SYSTEM)

#PEREVOD(Z,SYS) = Вызов функции перевода в любую систему из десятичной, Z,SYS передаваемые данные
#Z = Число которое мы переводим
#SYS = Система счисления в которую мы переводим
#AFT = Число после перевода
#ALF = Алфавит

#OBR(A, SYSTEM) = Вызов функции перевода в десятичную
#A = Число которое мы переводим
#SYSTEM = Система счисления из которой мы переводим

#ТЕОРИЯ ПО СРЕЗАМ
if THEORY == True:
    ALPHA="0123456789"
    a=ALPHA[:5] # Всё до числа с индексом 5 включительно
    b=ALPHA[5:] # Всё после числа с индексом 5 не включительно
    c=ALPHA[::-1] # Переворот числа
    d=ALPHA[5:7] # Числа начиная с индекса 5 не включительно до числа с индексом 7 включительно
    e=ALPHA[0] # Первое число
    f=ALPHA[-1] # Последнее число


#ТЕОРИЯ ПО ЛОГИЧЕСКИМ ОПЕРАЦИЯМ

# ¬ A, A = (not(A))
# A ∧ B, A ⋅ B = A and B
# A ∨ B, A + B = A or B
# A → B = A <= B
# A ↔ B, A ≡ B, A ∼ B = A==B
# A ⊕ B = A != B


#ТЕОРИЯ ПО ЧЕРЕПАХЕ

# Внутри без учета границ (n-1)(m-1)
# С учетом границ (n+1)(m+1)
# Площадь n*m
# Периметр (n+m)*2



#ОБРАЗЦЫ РЕШЕНИЯ ЗАДАЧ

# 2

if NUM2 == True:
    print("x y z w")
    for x in range(2):
        for y in range(2):
            for z in range(2):
                for w in range(2):
                    if ((x or y) and (not(y==z)) and (not(w))) == 1:  #((x or y) and (not(y==z)) and (not(w))) - Логическое выражение
                        print(x,y,z,w)


# 5

if NUM5==True:
    def PEREVOD(Z,SYS):
        AFT=""
        ALF="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        while Z!=0:
            if Z%SYS<=9:
                AFT+=str(Z%SYS)
            else:
                AFT+=ALF[(Z%SYS)-10]
            Z=Z//SYS
        AFT=AFT[::-1]
        return(AFT)

    for N in range(1, 10000):
        Z=PEREVOD(N,2)
        if N%3==0:
            Z=Z+Z[-3:]
        else:
            Z=Z+PEREVOD((N%3)*3,2)
        R=int(Z,2)
        if R>=200:
            print(N)
            break


# 6
if NUM6==True:
    import turtle
    from turtle import *

    t=turtle                # Чтобы не писать постоянно turtle.left(90) или turtle.forward(34*k)
    k=10                    # Чтобы линии были подлиннее
    screensize(3000,3000)   # Размеры окна
    t.left(90)              # Т.к. в питоне черепаха изначально смотрит вправо 
    tracer(0)               # Без анимации

    for i in range(2):
        t.forward(14*k)
        t.left(270)
        t.back(12*k)
        t.right(90)

    t.up()                  # Поднять хвост

    t.forward(9*k)
    t.right(90)
    t.back(7*k)
    t.left(90)

    t.down()                # Опустить хвост

    for i in range(2):
        t.forward(13*k)
        t.right(90)
        t.forward(6*k)
        t.right(90)

    t.up()

    for x in range(-20, 30):
        for y in range(-10, 30):
            goto(x * k, y * k)      # Go To Position, перемещаем черепаху на нужную координату
            dot(5,'red')            # Точка с радиусом 5 красного цвета

    done()                  # Чтобы окно не закрывалось


# 8.1

if NUM8_LETTER==True:
    # Для слов из букв
    import itertools
    from itertools import *

    k=0
    for x in product("АКОРСТ", repeat=5):  # repeat= - длина слова
        WORD=""
        for i in x:
            WORD+=i
        k+=1  # Если узнать под каким номером
        if k%2==0:  # Четный номер
            if WORD[0]!="A" and WORD[0]!="С" and WORD[0]!="Т":  # Не начинается с А, С или Т
                if WORD.count("О")==2:  # Только 2 буквы О
                    print(k,WORD)


# 8.2

if NUM8_NUMBER==True:
    # Для слов из цифр
    import itertools
    from itertools import *

    k=0
    for x in product("0123456", repeat=7):  # repeat= - длина слова
        NUM=""
        for i in x:
            NUM+=i
        if NUM[0]!="0": # Т.к. числа не могут начинаться с 0
            NUM1=NUM  # Создаём дубликат строки если будем что-то менять
            NUM1=NUM1.replace("0","*").replace("2","*").replace("4","*").replace("6","*").replace("1","X").replace("3","X").replace("5","X") 
            if NUM1.count("*X")==2:  # Содержит ровно 2 сочетания вида чет+нечёт
                k+=1  # Если нужно посчитать кол-во
    print(k)
            

# 12

# Машину Тьюринга игнорируем, т.к. проще решить руками
# Смотрим исполнителя "Редактор"
if NUM12 == True:
    for n in range(3,10001):
        STROKA = "1"+ "2"*n
        
        while ("12" in STROKA) or ("322" in STROKA) or ("222" in STROKA):
            if "12" in STROKA:
                STROKA=STROKA.replace("12", "2", 1) # Заменить 12 на 2 только 1 раз
            if "322" in STROKA:
                STROKA=STROKA.replace("322", "21", 1)
            if "222" in STROKA:
                STROKA=STROKA.replace("222", "3", 1)
        SUMM=0
        for i in STROKA:
            SUMM+=int(i)
        
        if SUMM==15:
            print(n)
            break
            
# 13
if NUM13==True:
    print(bin(255)[2:].zfill(8),bin(255)[2:].zfill(8),bin(255)[2:].zfill(8),bin(240)[2:].zfill(8))
    print(bin(162)[2:].zfill(8),bin(198)[2:].zfill(8),bin(0)[2:].zfill(8),bin(157)[2:].zfill(8))
    print(bin(192)[2:].zfill(8),bin(168)[2:].zfill(8),bin(248)[2:].zfill(8),bin(176)[2:].zfill(8))

# 14.1
# Значение ариф. выражения ALPHA записали в системе счисления с основанием X, определите кол-во цифр с числ значением 
if NUM14_1 == True:
    def PEREVOD(Z,SYS):
        AFT=""
        ALF="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        while Z!=0:
            if Z%SYS<=9:
                AFT+=str(Z%SYS)
            else:
                AFT+=ALF[(Z%SYS)-10]
            Z=Z//SYS
        AFT=AFT[::-1]
        return(AFT)

    alph="ABCDEFGHIJKLMNOPQ"
    K=2*2187**2020+729**2021-2*243**2022+81**2023-2*27**2024-6561
    C=PEREVOD(K,27)
    counter=0
    for i in alph:
        counter+=C.count(i)
    print(counter)


# 14.2
# Операнды ариф. выражения записаны в системе счисления с основанием x, вычислите частное от деления ариф. выражения на y
if NUM14_2 == True:
    alph="0123456789ABCDEFGHIJKLMNOPQRS"
    for x in alph:
        A=int(f"923{x}874",29)+int(f"524{x}6152",29)
        if A%28==0:
            print(f"Для x = {x}, Ответ: {A//28}")


# 14.3
# Значение ариф. выражения где x - целое положительное не привышающее y записали в z-ричной системе счисления, определите значение x при котором в z-ричной записи содержится d чего-то
if NUM14_3==True:
    def PEREVOD(Z,SYS):
        AFT=""
        ALF="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        while Z!=0:
            if Z%SYS<=9:
                AFT+=str(Z%SYS)
            else:
                AFT+=ALF[(Z%SYS)-10]
            Z=Z//SYS
        AFT=AFT[::-1]
        return(AFT)

    for x in range(1,3001):
        V = 9*11**210+8*11**150-x
        AFTER = PEREVOD(V,11)
        if AFTER.count("0")==60:
            print(x)


# 15
if NUM15 == True:
    P=list(range(15,41)) # Отрезок P от 15 до 40
    Q=list(range(21,63)) # Отрезок Q от 21 до 62
    A=[] 

    k=0
    for x in range(10,70):
        if ((x in P)<=(((x in Q) and (not(x in A)))<=(not(x in P)))) == 0: # Идём от обратного чтобы не считать сколько раз должно быть 1
            A.append(x) # Я не объясню, это просто надо запомнить
    print(A)
# Если требуют наименьшую возвожную длину - добавляем, если требуют наибольшую - убираем
# Ответом всегда будет разность между какими-то числами отрезков


# 16
if NUM16 == True:
    import functools
    from functools import *

    @cache
    def G(n):
        if n < 10:
            return 2*n
        if n >= 10:
            return G(n-2)+1
        
    @cache
    def F(n):
        return 2*(G(n-3)+8)
    
    for i in range(16000):
        F(i)

    print(F(15548))

# 17
if NUM17 == True:
    f=open("17_23757.txt") # Открываем данный файл

    B=[] # Просто массив для хранения чисел с файла
    dv_ch=[] # Массив двузначных чисел
    for i in f:
        B.append(int(i)) # Добавляем числа из файла в массив B
    
    for i in B:
        if len(str(i))==2: # Проверка является ли число двузначным
            dv_ch.append(int(i)) 
    
    min_dv_ch=min(dv_ch) # Минимальное двузначное число

    OTV=[] # Массив с подходящими условию суммами чисел
    for i in range(len(B)-1): # Берём числа от 0 и до кол-ва чисел в массиве B (-1 для того чтобы пары нормально работали)
        a=B[i] # Число из массива B с индексом i
        b=B[i+1] # Пара к числу a
        
        if ((len(str(a))==2) + (len(str(b))==2)) == 1: # Условие 1
            if (a+b)%min_dv_ch==0: # Условие 2
                OTV.append(a+b)
    print(len(OTV),max(OTV)) # len(OTV) - длина массива, т.е. кол-во пар подходящих условию. max(OTV) - наибольшая сумма пар 


# 23
if NUM23 == True:
    def F(x,y): # x - число от которого идём, y - число к которому мы идём
        if x==y:
            return 1
        if x<y or x==7: # x<y - если мы перешагнули, т.е. не туда пошёл алгоритм, x==7 - по условию не содержит число 7
            return 0
        
        k=0
        k+=F(x-1,y)
        k+=F(x-4,y)
        k+=F(x//3,y)
        return k
    
    print(F(19,13)*F(13,2)) # Сколько существует алгоритмов идущих от 19 до 13 (должны пройти через 13 по условию) и от 13 до конечного числа 2 (умножение можно объяснить графом, но я его тут чертить не собираюсь)


# 24.1
# Самый распространенный тип. Нужно найти самую длинную цепочку, где выполняется условие для соседних символов.
# "Символы не должны совпадать", "Символы должны строго чередоваться", "Рядом не может стоять две буквы A".
if NUM24_1==True:
    with open("24.txt") as f:
        s = f.readline().strip()
    k = 1                           # Текущая длина цепочки
    k_max = 1                       # Максимальная длина
    for i in range(len(s) - 1):     # (len(s) - 1), чтобы s[i+1] не вылетел за границу строки
        if s[i] != s[i+1]:          # Условие
            k += 1
            k_max = max(k_max, k)
        else:
            k = 1
    print(k_max)


# 24.2
# Нужно найти самую длинную подстроку, состоящую только из определенных букв (или, наоборот, не содержащую какую-то букву).
# "Найти самую длинную цепочку, состоящую только из букв A, B и C"
if NUM24_2==True:
    with open("24.txt") as f:
        s = f.readline().strip()
    s = s.replace('C', ' ') 
    parts = s.split() 
    print(max(len(x) for x in parts))


# 24.3
# Нужно найти максимальное количество идущих подряд групп символов
if NUM24_3==True:
    with open("24.txt") as f:
        s = f.readline().strip()
    s = s.replace('XYZ', '*') # Превратили тройки в звездочки

    # ВАЖНО: нужно убрать все старые символы, которые могли помешать
    for char in 'XYZ': 
        s = s.replace(char, ' ')

    # Теперь у нас строка вида "* ** **** *"
    parts = s.split()
    max_stars = max(len(x) for x in parts)
    print(max_stars * 3) # Умножаем на 3, так как одна звезда = 3 символа


# 24.4
# Найти максимальную длину подстроки, в которой символ 'A' встречается не более 5 раз
if NUM24_4==True:
    with open("24.txt") as f:
        s = f.readline().strip()
    # 1. Собираем индексы всех букв 'A'
    # Добавляем фиктивные границы: -1 (начало) и len(s) (конец)
    indexes = [-1] + [i for i, x in enumerate(s) if x == 'A'] + [len(s)] # Создает список номеров мест, где стоят буквы 'А'.

    k_max = 0
    N = 5 # Сколько букв 'A' разрешено

    # 2. Проходим по списку индексов
    for i in range(len(indexes) - N - 1):
        # Формула: (правый индекс) - (левый индекс) - 1
        # Мы берем окно шириной N+1, чтобы внутри оказалось ровно N букв 'A'
        length = indexes[i + N + 1] - indexes[i] - 1
        k_max = max(k_max, length)

    print(k_max)


# 25.1
if NUM25_1 == True:
    import math
    from math import *

    LIST=list(range(800000,800000+5000)) # Числа большие 800000
    k=0
    for x in LIST:
        A=set() # Почему не list()? Всё просто, чтобы делители не повторялись
        for i in range(2, int(sqrt(x)+1)): # Идём от 2 (т.к. нужны делители не считая 1 и самого числа) до корня из числа (т.е. ровно до середины) 
            if x%i==0: # Действительно ли i является делителем числа x?
                A.add(i) # Добавляем делитель
                A.add(x//i) # Добавляем парный делитель (возьмём к примеру делители числа 20: 1 2 4 5 10 20. Парный к делителю 1 - 20, к делителю 2 - 10 и т.д.)
        A=sorted(A) # Превращаем сложный массив в простой просто отсортировав его
        if len(A)!=0: # Если список натуральных делителей не пуст
            M=max(A)+min(A) # M – сумма минимального и максимального натуральных делителей целого числа, не считая единицы и самого числа.
            if str(M)[-1]=="4": # Если M оканчивается на 4
                print(x,M)
                k+=1 # Эти 3 строки чтобы просто вывести первые 10 чисел подходящих по всем условиям
                if k==10:
                    break
# Если в 25.1 просят найти простые делители числа, то это конечно жопа, но решаемо. Проще всего будет вынести проверку на делители в функцию и работать с ней, ибо иначе будет овердохрена строк кода в которых запутаться проще простого


# 25.2
if NUM25_2 == True:
    import fnmatch
    from fnmatch import *

    for x in range(0,10**10,1917): # Идём от 0 до данного нам по условию лимита 10**10 с шагом равным нашему делителю чтобы обработка шла быстрее
        if fnmatch(str(x),"3?12?14*5"): # Подходит ли число x (обязательно строковое) 
            if x%1917==0: # Повторная проверка делится ли
                print(x,x//1917)
# Если в 25.2 в маске просят четную или нечётную, беги


# 26.1
# Тип "Системный администратор" (Максимальный объём)
if NUM26_1 == True:
    f = open('26.txt') 
    S, N = map(int, f.readline().split())
    a = sorted([int(x) for x in f])

    # 1 часть: сколько файлов влезет
    count = 0
    current_sum = 0
    selected = []

    for x in a:
        if current_sum + x <= S:
            current_sum += x
            count += 1
            selected.append(x)
        else:
            break

    print(count)

    # 2 часть: замена последнего на самый большой
    current_sum -= selected[-1] # Убираем последний
    for x in a[::-1]: # Идем по списку с конца (самых больших)
        if current_sum + x <= S:
            print(x)
            break


# 26.2
# Тип "Мероприятия" (Расписание)
if NUM26_2 == True:
    f = open('26.txt')
    n = int(f.readline())
    events = []
    for _ in range(n):
        events.append(list(map(int, f.readline().split())))

    # Сортируем по ВТОРОМУ значению (времени окончания)
    events.sort(key=lambda x: x[1])

    count = 1
    last_end = events[0][1]

    for i in range(1, n):
        if events[i][0] >= last_end: # Если начало >= конца предыдущего
            count += 1
            last_end = events[i][1]

    print(count)


# 26.3
# Тип "Камера хранения" (Ячейки)
if NUM26_3 == True:
    f = open('26.txt')
    K = int(f.readline()) # кол-во ячеек
    N = int(f.readline()) # кол-во людей
    passengers = sorted([list(map(int, x.split())) for x in f])

    cells = [0] * K # время освобождения каждой ячейки
    total_count = 0
    last_cell_index = 0

    for start, end in passengers:
        for i in range(K):
            if cells[i] < start: # Нашли свободную!
                cells[i] = end
                total_count += 1
                last_cell_index = i + 1 # Номера обычно с 1
                break

    print(total_count, last_cell_index)


# 27.1
if NUM27_1 == True:
    f = open('27_B_18314.txt')
    f.readline() # Отсекаем 1 строку т.к. в ней просто прописаны буквы x и y

    cl_1 = [] # Кластер 1
    cl_2 = [] # Кластер 2
    cl_3 = [] # Кластер 3

    for i in f:
        x,y = map(float,i.replace(',','.').split()) # Записываем координаты в переменные x,y делая из них значения float функцией map (применяет заданную функцию ко всем аргументам) и при этом заменяем запятые на точки ибо питон с запятыми работать не умеет
        if x < -10: # Отсекаем кластеры друг от друга
            cl_1.append([x,y]) # Добавляем в массив кластеров звёзды к нему относящиеся
        if x > 16:
            cl_2.append([x,y])
        if (x>-10)and(x<16):
            cl_3.append([x,y])

    def centroid(cl): # Функция которая ищет центроид кластера (бывают и минимальное и максимальное расстояние, читай условие)
        min_sum = 10 ** 10 # Берём наибольшее чтобы найти наименьшее
        for i in cl: # i - координаты 1 звезды
            summ_dlin = 0
            for j in cl: # j - координаты 2 звезды
                dlina = abs(j[0]-i[0])+abs(j[1]-i[1]) # Формула Манхэттенского расстояния (бывает и другое, читай условие)
                summ_dlin += dlina
            if summ_dlin < min_sum: # Если сумма длин от 1 звезды до остальных меньше чем текущая минимальная сумма, то перезаписываем
                min_sum = summ_dlin
                centr_cl = i 
        return centr_cl

    centr_1 = centroid(cl_1)
    centr_2 = centroid(cl_2)
    centr_3 = centroid(cl_3)

    Px = int((centr_1[0] + centr_2[0] + centr_3[0]) / 3 * 1000) # По условию ср. ариф координаты x центроидов умноженное на 1000
    Py = int((centr_1[1] + centr_2[1] + centr_3[1]) / 3 * 1000) # По условию ср. ариф координаты y центроидов умноженное на 1000

    print(Px,Py)


# 27.2
# Отличие от 27.1 в том, что используется формат расстояния от одной точки до другой вместо ограничения поля действия
if NUM27_2 == True:
    from math import *
    f=open('27_B_25364.txt')
    tochki=[]
    cls = []
    for i in f:
        x,y = map(float,i.replace(',','.').split())
        tochki.append([x,y]) # Мы превращаем файл в список координат [[x1, y1], [x2, y2], ...]. Теперь tochki — это наш "общий склад" всех звезд.

    while len(tochki) > 0: # Цикл while будет работать до тех пор, пока мы не распределим все точки по кластерам.
        cl = [tochki.pop()] # tochki.pop() вырезает точку из общего списка. Теперь эта точка — "первый кирпичик" в новом кластере cl
        for i in cl: # Мы берем точку i из текущего кластера cl
            for j in tochki: # Перебираем все точки j из "общего склада" (tochki)
                if dist(i,j) < 3: # Если расстояние между ними меньше 3 (они соседи)
                    cl.append(j) # Мы добавляем j в конец списка cl
                    tochki.remove(j) # Мы удаляем j из "общего склада" (чтобы она не попала в другой кластер)
        cls.append(cl) # Когда соседи закончились, сохраняем кластер в общий список кластеров

    cls=sorted(cls, key=len) # Кластеры могут найтись в любом порядке. Чтобы обратиться к самому большому или самому маленькому, мы их сортируем по количеству точек (len)


    def centroid(cl): # Функция которая ищет центроид кластера (бывают и минимальное и максимальное расстояние, читай условие)
        min_sum = 10 ** 10 # Берём наибольшее чтобы найти наименьшее
        for i in cl: # i - координаты 1 звезды
            summ_dlin = 0
            for j in cl: # j - координаты 2 звезды
                dlina = sqrt((j[0]-i[0])**2+(j[1]-i[1])**2)
                summ_dlin += dlina
            if summ_dlin < min_sum: # Если сумма длин от 1 звезды до остальных меньше чем текущая минимальная сумма, то перезаписываем
                min_sum = summ_dlin
                centr_cl = i 
        return centr_cl

    centr_1 = centroid(cls[0])
    centr_2 = centroid(cls[1])
    centr_3 = centroid(cls[2])

    Q1=0
    for i in cls[2]:
        if dist(i,centr_3)<=1.2:
            Q1+=1

    Q2=0
    for i in cls[2]:
        if dist(i,centr_3)<=0.75:
            Q2+=1

